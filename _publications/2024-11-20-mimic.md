---
title: "Mimic In-Context Learning in Multimodal Tasks"
collection: publications
category: conferences
permalink: /publication/2025-11-20-mimic
excerpt: 'MimIC is a novel framework that mimics in-context learning for multimodal tasks by injecting lightweight, query-conditioned shift vectors after each attention head. Applied to Idefics1-9B, MimIC achieves up to +3.46% accuracy improvement on VQAv2, +3.57% on OK-VQA, and +9.00 CIDEr on image captioning, compared to standard 32-shot in-context learning. Moreover, MimIC effectively mitigates hallucination commonly introduced by conventional ICL approaches, while incurring inference overhead comparable to zero-shot inference.'
date: 2025-04-11
venue: 'CVPR'
authors: 'Yuchu Jiang, Jiale Fu, Chenduo Hao, Xinting Hu, Yingzhe Peng, Xin Geng, Xu Yang'
paperurl: 'https://arxiv.org/abs/2502.01662v1'
citation: 'Jiang Y, Fu J, Hao C, et al. Mimic In-Context Learning for Multimodal Tasks[J]. arXiv preprint arXiv:2504.08851, 2025.'
---

<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>

# 1. Introduction: Toward Efficient and Stable Multimodal ICL
While In-Context Learning (ICL) empowers Large Multimodal Models (LMMs) to generalize without fine-tuning, its performance is highly sensitive to in-context demonstration (ICD) configurations and incurs considerable computational costs, especially under long image-text contexts.

We propose MimIC, a novel framework that mimics the shift effect of ICL by inserting lightweight, query-dependent shift vectors into attention heads. Unlike standard ICL, MimIC eliminates the need for ICD configuration at inference time, offering robust performance with fewer training samples and lower latency. Experiments show that MimIC matches or surpasses 32-shot ICL across VQA, OK-VQA, and captioning tasks, while reducing hallucinations and outperforming prior shift-based methods.

# 2. Mechanism Behind ICL: a Shift Vector View
Numerous studies have sought to explain the underlying mechanisms of In-Context Learning (ICL) from various perspectives. Some interpret ICL as a form of implicit Bayesian inference, while others decompose it into task identification and task learning. In this work, we adopt a shift vector perspective. Under this framework, In-Context Demonstrations (ICDs) are viewed as inducing a shift in the representation of the original query, as illustrated in <a href="#fig1">Figure 1(a)</a>.
<div class="figure" id="fig1"> 
<img src="https://kamichanw.github.io/files/mimic/teaser.png" alt="Paper Figure 1"  />
<p><i>Figure 1.</i> Sketches of shift effects from query space to answer space. (a) Traditional ICL induces the shift vector by ICDs, which is sensitive to ICD configurations, <i>i.e.</i>, changing one ICD make prediction incorrect. (b) Previous shift vector-based methods insert a query-independent shift vector learned from a large training set, causing equal shift magnitude for diverse queries, which may make prediction incorrect. (c) MimIC assigns a unique query-dependent shift vector learned from fewer training samples after each attention head layer, shifting diverse magnitude for different queries, thus achieving stronger generalization ability.</p>
</div>
However, this shift is inherently unstable, as variations in the order or selection of ICDs can lead to substantial differences in model performance. To address this issue, prior work has proposed heuristic approaches to estimate a shift vector, which is then applied to certain layers of the model to emulate the effect of ICDs. As illustrated in <a href="#fig1">Figure 1(b)</a>, these methods remain fixed during inference—that is, the same precomputed shift is applied to all queries—which limits their ability to adapt to complex and diverse task settings. In this work, we build upon the mathematical formulation of the shift vector view to propose a more principled and precise approach to shift simulation. As shown in <a href="#fig1">Figure 1(c)</a>, our method accounts for variations across different attention heads, enabling the model to capture information in multiple subspaces. Furthermore, it dynamically adjusts the magnitude of the shift based on the input query, introducing adaptability. Extensive experiments validate the effectiveness of our proposed method.


## 3 Mimicking In-Context Learning
### 3.1 Mathematic Analyses
In this section, we provide a mathematical explanation for why ICDs can be interpreted as a shift vector applied to the query.

ICL allows large language models (LLMs) or large multimodal models (LMMs) to generalize to new tasks by providing a few ICDs directly in the input. Formally, the prompt context is defined as \\( C = \\{ X_D, X \\} \\), where \\( X_D = \\{X_1, X_2, \dots, X_k\\} \in \mathbb{R}^{l_D \times d} \\) represents the concatenation of \\( k \\) ICDs, and  \\( X \in \mathbb{R}^{l_q \times d} \\) is the query input. Here, \\( l_D \\) and \\( l_q \\) denote the number of tokens in \\( X_D \\) and \\( X \\), respectively, and \\( d \\) is the embedding dimension.

Multi-head self-attention applies the self-attention (SA) mechanism over \\( N_h \\) heads, each parameterized by weight matrices \\( W_k, W_q, W_v \in \mathbb{R}^{d \times d_h} \\) to project \\( C \\) into keys \\( K_C \\), queries \\( Q_C \\), and values \\( V_C \\). Typically, \\( d_h \\) is set to \\( d/N_h \\) to reduce parameter usage by operating each attention head in a lower-dimensional space. For a specific head, the key mapping is defined as:

$$
    K_C = C W_k = \begin{bmatrix} X_D \\ X \end{bmatrix} W_k = \begin{bmatrix} K_D \\ K \end{bmatrix}.
$$

Similarly, we compute the corresponding \\( Q_D, Q \\), and \\( V_D, V \\) using \\( W_q \\) and \\( W_v \\), respectively. For each query vector \\( q \in Q \\), the single-head self-attention operation is:

$$
\begin{aligned}
& \text{SA} \left(q, \begin{bmatrix} K_D \\ K \end{bmatrix}, \begin{bmatrix} V_D \\ V \end{bmatrix} \right) \\
&= \text{softmax}\left( \begin{bmatrix} q K_D^\top, q K^\top \end{bmatrix} \right) \begin{bmatrix} V_D \\ V \end{bmatrix} \\
&= \left[ \frac{\exp\left(q K_D^\top\right)}{Z_1+Z_2}, \frac{\exp\left(q K^\top\right)}{Z_1+Z_2}\right] \begin{bmatrix} V_D \\ V \end{bmatrix} \\
&= \frac{Z_2}{Z_1+Z_2} \frac{\exp(q K^\top)}{Z_2} V + \frac{Z_1}{Z_1+Z_2} \frac{\exp(q K_D^\top)}{Z_1} V_D \\
&= \frac{Z_2}{Z_1+Z_2} \text{softmax}(q K^\top) V + \frac{Z_1}{Z_1+Z_2} \text{softmax}(q K_D^\top) V_D \\
&= (1 - \mu) \text{SA}(q, K, V) + \mu \text{SA}(q, K_D, V_D) \\
&= \underbrace{\text{SA}(q, K, V)}_{\text{standard attention}} + \underbrace{\mu \left(\text{SA}(q, K_D, V_D) - \text{SA}(q, K, V)\right)}_{\text{shift vector}}
\end{aligned}
$$

where \\( \mu \\) is a scalar representing the normalized attention weights over the ICDs:

\\[
\mu(q, K_D, K) = \frac{Z_1(q, K_D)}{Z_1(q, K_D) + Z_2(q, K)},
\\]

where $$ Z_1(q, K_D) = \sum_{i=1}^{l_D} \exp(q K_D^\top)_i $$ and $$ Z_2(q, K) = \sum_{j=1}^{l_q} \exp(q K^\top)_j $$.

SA equation shows that the self-attention over the prompt context \\( C \\) can be decomposed into two terms. The first term, "standard attention", is the self-attention over the query tokens and is independent of the ICDs. The second term, "shift vector", represents the effect of ICDs in shifting the query space toward the answer space. This shift effect is computed as the attention between the ICDs and the query \\( q \\), and is governed by the difference term \\( \text{SA}(q, K_D, V_D) - \text{SA}(q, K, V) \\) and the scalar \\( \mu(q, K_D, K) \\), both of which are dependent on the ICDs.

# 3.2 Mimicking ICD Affected Terms
From equations of \\(\mu \\) and SA, we observe that only \\( SA(q,K_D,V_D) \\) and \\( Z1(q,K_D) \\) are affected by ICDs. Let's tackle them one by one.
<div class="figure" id="fig2"> 
<img src="https://kamichanw.github.io/files/mimic/mimic-attn.png" alt="Paper Figure 2"  />
<p><i>Figure 2.</i> MimIC attention head. MimIC changes the attention mechanism for each head, which inserts a learnable shift vector with a query-dependent magnitude.</p>
</div>

To approximate \\( Z_1(q, K_D) \\), we note that it is a positive scalar dependent solely on the current query token \\( q \\) and the ICD keys \\( K_D \\). Therefore, we use a simple mapping: a trainable linear layer \\( f(\cdot): \mathbb{R}^{d_h} \to \mathbb{R} \\) to approximate \\( \log Z_1 \\). For the attention difference term, as shown in <a href="#fig2">Figure 2</a>, we insert a learnable vector \\( v \in \mathbb{R}^{d_h} \\) in each attention head to capture the general shift effect for this head. Then, the output of equation of SA in a MimIC attention head is computed as: \\[ \operatorname{SA}(q, K, V) + \tilde{\mu}(q, K) v, \\] where \\( \tilde{\mu}(q, K) = \tilde{Z_1}(q)/(\tilde{Z_1}(q) + Z_2(q, K)) \\) and \\( \tilde{Z_1}(q) = \exp(f(q)) \\). After obtaining the outputs from all MimIC attention heads, they are concatenated, flattened, and passed through the matrix \\( W_o \in \mathbb{R}^{d \times d} \\) and a feed-forward network (FFN) layer.

<div class="figure" id="fig3"> 
<img src="https://kamichanw.github.io/files/mimic/framework.png" alt="Paper Figure 3"  />
<p><i>Figure 3.</i> Overall training framework of MimIC. (a) The original LMM processes k ICDs and query input as conventional ICL, generating hidden states H1' to HN' at each layer. (b) In MimIC LMM, only a single query input X is processed, producing shifted hidden states H1 to HN, which are aligned with the original hidden states via the alignment loss L_align. Additionally, the logits of language modeling head is used to compute ground truth loss L_gt. The yellow blocks represent MimIC attention heads.
</p>
</div>

Given this MimIC attention head, we replace all the self-attention heads of the original LMM to obtain the **MimIC LMM** as shown in <a href="#fig3">Figure 3(b)</a>. Then we hope MimIC LMM can handle a single query \\( X \\) in the same way the original LMM implements ICL, <i>i.e.</i>, using the ICDs \\( X_D \\) to produce the result for \\( X \\).
To achieve this, given a training set, we randomly select \\( k \\) samples as ICDs \\( X_D \\) and one sample as the query \\( X \\). As shown in <a href="#fig3">Figure 3(a)</a>, for the original LMM, we input the context \\( C = \\{X_D, X\\} \\) into it to get the hidden states at each layer, which are recorded as \\( \mathcal{H}^\prime = \\{H_1^\prime, \dots, H_N^\prime\\} \\).
For MimIC LMM, we only input \\( X \\) into it to get the hidden states \\( \mathcal{H} = \\{H_1, \dots, H_N\\} \\). To make MimIC LMM behave similarly to the original LMM, we set an alignment loss $$ \mathcal{L}_{\text{align}} $$, <i>i.e.</i>, layer-wise MSE, to make \\( \mathcal{H} \\) close to \\( \mathcal{H}^\prime \\). In addition, we employ the language modeling loss $$ \mathcal{L}_{\text{gt}}$$ to enhance the model's performance on downstream tasks,

# 4. Experimental Results

## 4.1 Experimental Configuration

We evaluate MimIC on two representative vision-language models (LMMs): Idefics-9b and Idefics2-8b-base, referred to as Idefics1 and Idefics2. Experiments are conducted on three benchmark datasets: VQAv2, OK-VQA, and COCO Caption. Idefics1 adopts a cross-attention architecture, while Idefics2 uses a fully autoregressive design, covering two dominant LMM paradigms. For each dataset, 1,000 samples are randomly selected for training. Evaluation follows existing protocols, using 10,000 validation samples from VQAv2 and full validation splits for OK-VQA and COCO.

## 4.2 Main Results

### Compared Baselines

We compare **MimIC** with the following baseline methods:

- **Zero-shot**: Direct inference without any in-context demonstration.
- **Few-shot ICL**: Classical in-context learning using 32-shot (Idefics1) or 8-shot (Idefics2) demonstrations.
- **RICES**: Retrieval-based in-context example selection using image similarity.
- **FV (Function Vector)**: Injects a compressed representation of task features into the model.
- **TV (Task Vector)**: Similar to FV but derived from a different transformation of ICDs.
- **LIVE**: Adds learned vectors post-FFN layers; trained under a MimIC-style loss.
- **LoRA**: Fine-tunes the model via low-rank adaptation on attention weights.
- **MimIC**: Our proposed method that mimics the shift induced by ICDs, with minimal trainable parameters.

### Performance Comparison

<table class="results">
  <thead>
    <tr>
      <th rowspan="2">Model</th>
      <th rowspan="2">Method</th>
      <th rowspan="2">#Params (M)</th>
    </tr>
    <tr>
      <th>VQAv2</th>
      <th>OK-VQA</th>
      <th>COCO</th>
    </tr>
  </thead>
  <tbody>
    <tr><td rowspan="8">Idefics1</td><td>Zero-shot</td><td>-</td><td>29.25</td><td>30.54</td><td>63.06</td></tr>
    <tr><td>32-shot ICL</td><td>-</td><td>56.18</td><td>48.48</td><td>105.89</td></tr>
    <tr><td>RICES</td><td>-</td><td>58.07</td><td>51.11</td><td>110.64</td></tr>
    <tr><td>FV</td><td>-</td><td>30.21</td><td>31.02</td><td>74.01</td></tr>
    <tr><td>TV</td><td>-</td><td>43.68</td><td>32.68</td><td>84.72</td></tr>
    <tr><td>LIVE</td><td>0.13 (×0.5)</td><td>53.71</td><td>46.05</td><td><u>112.76</u></td></tr>
    <tr><td>LoRA</td><td>25.0 (×96.2)</td><td><u>55.60</u></td><td><u>47.06</u></td><td>97.75</td></tr>
    <tr class="highlight"><td><strong>MimIC</strong></td><td><strong>0.26 (×1.0)</strong></td><td><strong>59.64</strong></td><td><strong>52.05</strong></td><td><strong>114.89</strong></td></tr>
    <tr><td rowspan="8">Idefics2</td><td>Zero-shot</td><td>-</td><td>55.39</td><td>43.08</td><td>40.00</td></tr>
    <tr><td>8-shot ICL</td><td>-</td><td>66.20</td><td>57.68</td><td>122.51</td></tr>
    <tr><td>RICES</td><td>-</td><td>66.44</td><td>55.73</td><td>111.44</td></tr>
    <tr><td>FV</td><td>-</td><td>36.47</td><td>34.58</td><td>75.24</td></tr>
    <tr><td>TV</td><td>-</td><td>47.12</td><td>38.27</td><td>87.61</td></tr>
    <tr><td>LIVE</td><td>0.13 (×0.5)</td><td><u>67.60</u></td><td>54.86</td><td><u>126.04</u></td></tr>
    <tr><td>LoRA</td><td>17.6 (×67.7)</td><td>66.54</td><td><u>55.05</u></td><td>116.69</td></tr>
    <tr class="highlight"><td><strong>MimIC</strong></td><td><strong>0.26 (×1.0)</strong></td><td><strong>69.29</strong></td><td><strong>58.74</strong></td><td><strong>132.87</strong></td></tr>
  </tbody>
</table>

> **Bold** numbers denote best results. <u>Underlined</u> numbers denote second-best.


<style>
.model-config, .results {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
}
.model-config th, .model-config td, .results th, .results td {
  border: 1px solid #ddd;
  padding: 8px;
  text-align: center;
}
.results th {
  background: #f8f9fa;
}
.highlight {
  background-color: #e3f2fd;
}
.figure {
  text-align: center;
  margin: 20px 0;
}
.figure img {
  max-width: 80%;
  border: 
}
.figure p {
  text-align: left;
  font-size: small;
}
</style>
  
